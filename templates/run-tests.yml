parameters:
  - name: environment
    type: string
  - name: databricksHost
    type: string
  - name: databricksToken
    type: string

steps:
  - task: PowerShell@2
    displayName: 'Discover Test Pipelines'
    inputs:
      targetType: 'inline'
      script: |
        Write-Host "============================================================"
        Write-Host "  Discovering Test Pipelines in ${{ parameters.environment }}"
        Write-Host "============================================================"
        
        $src = "$(Build.SourcesDirectory)"
        $pipelinesDir = Join-Path $src "pipelines"
        
        if (-not (Test-Path $pipelinesDir)) {
          Write-Host "‚ùå Error: 'pipelines' directory not found!" -ForegroundColor Red
          exit 1
        }
        
        # Get all pipeline folders
        $pipelineFolders = Get-ChildItem $pipelinesDir -Directory
        
        Write-Host "`nüìã Found $($pipelineFolders.Count) pipeline(s) to test:"
        foreach ($pf in $pipelineFolders) {
          Write-Host "  - $($pf.Name)"
        }
        
        # Store pipeline names for next steps
        $pipelineNames = $pipelineFolders | ForEach-Object { $_.Name }
        $pipelineNamesJson = $pipelineNames | ConvertTo-Json -Compress
        
        Write-Host "`n##vso[task.setvariable variable=PipelineNames]$pipelineNamesJson"
        Write-Host "============================================================"

  - task: PowerShell@2
    displayName: 'Run Pipeline Tests'
    inputs:
      targetType: 'inline'
      script: |
        Write-Host "============================================================"
        Write-Host "  Running Pipeline Tests in ${{ parameters.environment }}"
        Write-Host "============================================================"
        
        $headers = @{
          Authorization = "Bearer ${{ parameters.databricksToken }}"
          "Content-Type" = "application/json"
        }
        
        $pipelineNames = '$(PipelineNames)' | ConvertFrom-Json
        
        if (-not $pipelineNames -or $pipelineNames.Count -eq 0) {
          Write-Host "‚ö†Ô∏è  No pipelines to test. Skipping test execution."
          exit 0
        }
        
        $allTestsPassed = $true
        $testResults = @()
        
        foreach ($pipelineName in $pipelineNames) {
          Write-Host "`n============================================================"
          Write-Host "üß™ Testing Pipeline: $pipelineName"
          Write-Host "============================================================"
          
          $testBasePath = "/Workspace/Shared/Tests/$pipelineName"
          
          # Step 1: Run upload_to_adls.bat
          Write-Host "`nüì§ Step 1: Running upload_to_adls.bat..."
          try {
            $uploadBatPath = "$testBasePath/utils/upload_to_adls.bat"
            
            # Create notebook to execute the bat file
            $uploadNotebook = @'
# Databricks notebook source
import subprocess
import os

print("=" * 60)
print("Running upload_to_adls.bat")
print("=" * 60)

# Read the bat file content
with open("/Workspace/Shared/Tests/{0}/utils/upload_to_adls.bat", "r") as f:
    commands = f.readlines()

# Execute commands
for cmd in commands:
    cmd = cmd.strip()
    if cmd and not cmd.startswith("@") and not cmd.startswith("REM"):
        print(f"Executing: {{cmd}}")
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        print(result.stdout)
        if result.returncode != 0:
            print(f"Error: {{result.stderr}}")
            raise Exception(f"Command failed: {{cmd}}")

print("‚úÖ upload_to_adls.bat completed successfully")
'@ -f $pipelineName
            
            $b64Content = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($uploadNotebook))
            
            $uploadBody = @{
              path      = "$testBasePath/temp_upload_runner"
              content   = $b64Content
              language  = "PYTHON"
              overwrite = $true
              format    = "SOURCE"
            } | ConvertTo-Json
            
            Invoke-RestMethod "${{ parameters.databricksHost }}/api/2.0/workspace/import" `
              -Headers $headers `
              -Method Post `
              -Body $uploadBody | Out-Null
            
            # Run the notebook as a job
            $uploadJobBody = @{
              run_name = "Upload_ADLS_${pipelineName}_${{ parameters.environment }}"
              tasks = @(
                @{
                  task_key = "upload_data"
                  notebook_task = @{
                    notebook_path = "$testBasePath/temp_upload_runner"
                  }
                  new_cluster = @{
                    spark_version = "13.3.x-scala2.12"
                    node_type_id = "Standard_DS3_v2"
                    num_workers = 1
                  }
                  timeout_seconds = 1800
                }
              )
            } | ConvertTo-Json -Depth 10
            
            $uploadRun = Invoke-RestMethod "${{ parameters.databricksHost }}/api/2.1/jobs/runs/submit" `
              -Headers $headers `
              -Method Post `
              -Body $uploadJobBody
            
            $uploadRunId = $uploadRun.run_id
            Write-Host "  ‚úÖ Upload job submitted (Run ID: $uploadRunId)"
            
            # Wait for completion
            $maxWait = 30
            $startTime = Get-Date
            $uploadCompleted = $false
            
            while (-not $uploadCompleted) {
              Start-Sleep -Seconds 10
              
              $runStatus = Invoke-RestMethod "${{ parameters.databricksHost }}/api/2.1/jobs/runs/get?run_id=$uploadRunId" `
                -Headers $headers `
                -Method Get
              
              $state = $runStatus.state.life_cycle_state
              
              if ($state -eq "TERMINATED") {
                $uploadCompleted = $true
                if ($runStatus.state.result_state -ne "SUCCESS") {
                  Write-Host "  ‚ùå Upload failed!" -ForegroundColor Red
                  $allTestsPassed = $false
                  continue
                }
                Write-Host "  ‚úÖ Upload completed successfully"
              }
              
              $elapsed = (Get-Date) - $startTime
              if ($elapsed.TotalMinutes -gt $maxWait) {
                Write-Host "  ‚ùå Upload timed out" -ForegroundColor Red
                $allTestsPassed = $false
                break
              }
            }
          } catch {
            Write-Host "  ‚ö†Ô∏è  upload_to_adls.bat not found or failed: $($_.Exception.Message)" -ForegroundColor Yellow
          }
          
          # Step 2: Run DLT Pipeline
          Write-Host "`nüöÄ Step 2: Running DLT Pipeline..."
          try {
            # Get pipeline ID
            $pipelineList = Invoke-RestMethod "${{ parameters.databricksHost }}/api/2.0/pipelines" `
              -Headers $headers `
              -Method Get
            
            $pipeline = $pipelineList.statuses | Where-Object { $_.name -eq $pipelineName } | Select-Object -First 1
            
            if (-not $pipeline) {
              Write-Host "  ‚ö†Ô∏è  DLT Pipeline '$pipelineName' not found. Skipping DLT run." -ForegroundColor Yellow
            } else {
              $pipelineId = $pipeline.pipeline_id
              Write-Host "  üìã Pipeline ID: $pipelineId"
              
              # Start pipeline update
              $updateBody = @{
                pipeline_id = $pipelineId
                full_refresh = $false
              } | ConvertTo-Json
              
              $updateResult = Invoke-RestMethod "${{ parameters.databricksHost }}/api/2.0/pipelines/$pipelineId/updates" `
                -Headers $headers `
                -Method Post `
                -Body $updateBody
              
              $updateId = $updateResult.update_id
              Write-Host "  ‚úÖ Pipeline update started (Update ID: $updateId)"
              
              # Wait for pipeline completion
              $maxWaitPipeline = 60
              $startTimePipeline = Get-Date
              $pipelineCompleted = $false
              
              while (-not $pipelineCompleted) {
                Start-Sleep -Seconds 15
                
                $updateStatus = Invoke-RestMethod "${{ parameters.databricksHost }}/api/2.0/pipelines/$pipelineId/updates/$updateId" `
                  -Headers $headers `
                  -Method Get
                
                $pipelineState = $updateStatus.update.state
                Write-Host "  ‚è≥ Pipeline state: $pipelineState"
                
                if ($pipelineState -in @("COMPLETED", "FAILED", "CANCELED")) {
                  $pipelineCompleted = $true
                  if ($pipelineState -ne "COMPLETED") {
                    Write-Host "  ‚ùå Pipeline failed with state: $pipelineState" -ForegroundColor Red
                    $allTestsPassed = $false
                    continue
                  }
                  Write-Host "  ‚úÖ Pipeline completed successfully"
                }
                
                $elapsedPipeline = (Get-Date) - $startTimePipeline
                if ($elapsedPipeline.TotalMinutes -gt $maxWaitPipeline) {
                  Write-Host "  ‚ùå Pipeline execution timed out" -ForegroundColor Red
                  $allTestsPassed = $false
                  break
                }
              }
            }
          } catch {
            Write-Host "  ‚ùå DLT Pipeline execution failed: $($_.Exception.Message)" -ForegroundColor Red
            $allTestsPassed = $false
          }
          
          # Step 3: Run test cases
          Write-Host "`nüß™ Step 3: Running test cases..."
          try {
            $testsPath = "$testBasePath/tests"
            
            # Create test runner notebook
            $testRunner = @'
# Databricks notebook source
import subprocess
import sys
import os

print("=" * 60)
print("Running Test Cases for {0}")
print("=" * 60)

# Install pytest
subprocess.check_call([sys.executable, "-m", "pip", "install", "pytest", "pytest-html", "--quiet"])

# Run tests
test_path = "/Workspace/Shared/Tests/{0}/tests"
result = subprocess.run(
    ["python", "-m", "pytest", test_path, "-v", "--tb=short", "--maxfail=1"],
    capture_output=True,
    text=True
)

print(result.stdout)
print(result.stderr)

if result.returncode != 0:
    raise Exception(f"Tests failed for {0}")

print("‚úÖ All tests passed for {0}!")
'@ -f $pipelineName
            
            $b64TestContent = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($testRunner))
            
            $testUploadBody = @{
              path      = "$testBasePath/temp_test_runner"
              content   = $b64TestContent
              language  = "PYTHON"
              overwrite = $true
              format    = "SOURCE"
            } | ConvertTo-Json
            
            Invoke-RestMethod "${{ parameters.databricksHost }}/api/2.0/workspace/import" `
              -Headers $headers `
              -Method Post `
              -Body $testUploadBody | Out-Null
            
            # Run test job
            $testJobBody = @{
              run_name = "Tests_${pipelineName}_${{ parameters.environment }}"
              tasks = @(
                @{
                  task_key = "run_tests"
                  notebook_task = @{
                    notebook_path = "$testBasePath/temp_test_runner"
                  }
                  new_cluster = @{
                    spark_version = "13.3.x-scala2.12"
                    node_type_id = "Standard_DS3_v2"
                    num_workers = 1
                  }
                  timeout_seconds = 3600
                }
              )
            } | ConvertTo-Json -Depth 10
            
            $testRun = Invoke-RestMethod "${{ parameters.databricksHost }}/api/2.1/jobs/runs/submit" `
              -Headers $headers `
              -Method Post `
              -Body $testJobBody
            
            $testRunId = $testRun.run_id
            Write-Host "  ‚úÖ Test job submitted (Run ID: $testRunId)"
            
            # Wait for test completion
            $maxWaitTest = 30
            $startTimeTest = Get-Date
            $testCompleted = $false
            
            while (-not $testCompleted) {
              Start-Sleep -Seconds 10
              
              $testStatus = Invoke-RestMethod "${{ parameters.databricksHost }}/api/2.1/jobs/runs/get?run_id=$testRunId" `
                -Headers $headers `
                -Method Get
              
              $testState = $testStatus.state.life_cycle_state
              
              if ($testState -eq "TERMINATED") {
                $testCompleted = $true
                if ($testStatus.state.result_state -ne "SUCCESS") {
                  Write-Host "  ‚ùå Tests failed!" -ForegroundColor Red
                  
                  # Try to get error details
                  try {
                    $output = Invoke-RestMethod "${{ parameters.databricksHost }}/api/2.1/jobs/runs/get-output?run_id=$testRunId" `
                      -Headers $headers `
                      -Method Get
                    
                    if ($output.error) {
                      Write-Host "  Error: $($output.error)" -ForegroundColor Red
                    }
                  } catch {
                    Write-Host "  Could not retrieve test output"
                  }
                  
                  $allTestsPassed = $false
                  $testResults += @{
                    Pipeline = $pipelineName
                    Status = "FAILED"
                  }
                  continue
                }
                Write-Host "  ‚úÖ All tests passed!"
                $testResults += @{
                  Pipeline = $pipelineName
                  Status = "PASSED"
                }
              }
              
              $elapsedTest = (Get-Date) - $startTimeTest
              if ($elapsedTest.TotalMinutes -gt $maxWaitTest) {
                Write-Host "  ‚ùå Test execution timed out" -ForegroundColor Red
                $allTestsPassed = $false
                $testResults += @{
                  Pipeline = $pipelineName
                  Status = "TIMEOUT"
                }
                break
              }
            }
          } catch {
            Write-Host "  ‚ùå Test execution failed: $($_.Exception.Message)" -ForegroundColor Red
            $allTestsPassed = $false
            $testResults += @{
              Pipeline = $pipelineName
              Status = "ERROR"
            }
          }
        }
        
        # Final Summary
        Write-Host "`n============================================================"
        Write-Host "  TEST EXECUTION SUMMARY - ${{ parameters.environment }}"
        Write-Host "============================================================"
        Write-Host "`nResults by Pipeline:"
        foreach ($result in $testResults) {
          $color = if ($result.Status -eq "PASSED") { "Green" } else { "Red" }
          $icon = if ($result.Status -eq "PASSED") { "‚úÖ" } else { "‚ùå" }
          Write-Host "  $icon $($result.Pipeline): $($result.Status)" -ForegroundColor $color
        }
        
        Write-Host "`n============================================================"
        if ($allTestsPassed) {
          Write-Host "‚úÖ ALL TESTS PASSED SUCCESSFULLY!" -ForegroundColor Green
          Write-Host "============================================================"
          exit 0
        } else {
          Write-Host "‚ùå SOME TESTS FAILED!" -ForegroundColor Red
          Write-Host "============================================================"
          exit 1
        }
